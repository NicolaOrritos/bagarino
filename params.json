{"name":"Bagarino","tagline":"bagarino sells you tickets","body":"bagarino\r\n========\r\n\"bagarino\" _sells_ you tickets and can tell a real ticket from a fake one. Simple, fast and RESTful.\r\nAsk it for a new ticket and it'll give you. Then ask it whether a ticket is still valid or expired. Or whether it is a fake. It'll know for sure.\r\nWhen tickets expire simply ask bagarino for new ones.\r\n\r\nbagarino can be used as a support for a licensing server and as an helper to other systems in an authentication scenario.\r\n\r\n\r\nInstall\r\n-------\r\n\tnpm install -g bagarino\r\n\r\nUsage\r\n-----\r\n_bagarino_ needs Redis (http://redis.io/) to be installed and running in order to work.\r\nTo start bagarino run the following command:\r\n\r\n\tsudo bagarino\r\n\r\n_bagarino_ is now up and running, listening for requests on port 8124.\r\nHere's a detailed guide on how to submit a request for creating new tickets and/or validating old ones.\r\n\r\n### New tickets\r\nObtain a new ticket:\r\n\r\n    http://localhost:8124/tickets/new?policy=requests_based\r\n    200 OK {\"result\":\"OK\",\"ticket\":\"7fd88ab09e40f99767e17df27a723d05562d573b\",\"expires_in\":100,\"policy\":\"requests_based\"}\r\n\r\nSee the status of the newly created ticket:\r\n\r\n    http://localhost:8124/tickets/7fd88ab09e40f99767e17df27a723d05562d573b/status\r\n    200 OK {\"status\":\"VALID\",\"expires_in\":99,\"policy\":\"requests_based\"}\r\n\r\nAfter some requests (99 more in this case) the ticket expires. Then, asking for it again will result in the following response:\r\n\r\n    200 OK {\"status\": \"EXPIRED\"}\r\n\r\nAsking for a non-existent ticket results in the following:\r\n\r\n    http://localhost:8124/tickets/321somenonsense123/status\r\n    404 Not Found {\"status\":\"ERROR\",\"cause\":\"not_found\"}\r\n\r\nBy default new tickets have a time-based expire policy and a time-to-live of 60 seconds.\r\nA different policy can be used by specifying the _\"policy\"_ parameter in query-string:\r\n * **policy=time_based** is the default one. Add \"seconds=300\" to make the ticket expire after the non-default delay of 5 minutes.\r\n * **policy=requests_based** makes the ticket expire after a certain amount of requests of its status you do to bagarino. By default it's 100 requests, but you can otherwise specify e.g. \"requests=500\" to make it last for 500 requests.\r\n * **policy=cascading** makes the ticket _depend_ on another one: once the _dependency_ ticket expires the _dependent_ one does as well.\r\n * **policy=manual_expiration** makes the ticket perpetual, unless you make it expire manually by calling the _\"expire\"_ verb (explained some lines below).\r\n * **policy=bandwidth_based** makes the ticket perpetual as well, but the number of requests for it that can be done within a minute is limited.\r\n\r\nLet's see some requests that create tickets with different expiration policies:\r\n\r\n    http://localhost:8124/tickets/new?policy=requests_based&requests=5\r\n    200 OK {\"result\":\"OK\",\"ticket\":\"62a315cd7bdae5e84567cad9620f82b5defd3ef0\",\"expires_in\":5,\"policy\":\"requests_based\"}\r\n    \r\n    http://localhost:8124/tickets/new?policy=requests_based\r\n    200 OK {\"result\":\"OK\",\"ticket\":\"0b4e20ce63f7de9a4a77910e7f909e5dba4538f3\",\"expires_in\":100,\"policy\":\"requests_based\"}\r\n    \r\n    http://localhost:8124/tickets/new?policy=time_based&seconds=120\r\n    200 OK {\"result\":\"OK\",\"ticket\":\"50ab14d6f5dd082e8ed343f7adb5f916fa76188a\",\"expires_in\":120,\"policy\":\"time_based\"}\r\n    \r\n    http://localhost:8124/tickets/new?policy=cascading&depends_on=f073145dfdf45a6e85d0f758f78fd627fa301983\r\n    200 OK {\"result\":\"OK\",\"ticket\":\"9ae23360fb4e9b3348917eb5e9b8a8e725b0dcb0\",\"depends_on\":\"f073145dfdf45a6e85d0f758f78fd627fa301983\",\"policy\":\"cascading\"}\r\n    \r\n    http://localhost:8124/tickets/new?policy=manual_expiration\r\n    200 OK {\"result\":\"OK\",\"ticket\":\"f57d75c23f6a49951a6e886bbc60de74bc02ef33\",\"policy\":\"manual_expiration\"}\r\n\r\nWhen using the manual expiration policy you must call an appropriate verb to make the ticket expire:\r\n\r\n    http://localhost:8124/tickets/f57d75c23f6a49951a6e886bbc60de74bc02ef33/expire\r\n    200 OK {\"status\":\"EXPIRED\"}\r\n\r\nSubsequent requests for that ticket will give an \"EXPIRED\" status.\r\n\r\nFinally, bandwidth-based tickets can be created with the following requests:\r\n\r\n\thttp://localhost:8124/tickets/new?policy=bandwidth_based&reqs_per_minute=100\r\n    200 OK {\"result\": \"OK\", \"ticket\": \"2966c1fc73a0d78c96bdc18fb67ed99af1356b8a\", \"requests_per_minute\": 100, \"policy\": \"bandwidth_based\"}\r\n\r\n\r\n### Valid tickets\r\nAsking for a ticket status is all you can do with a newly created ticket. bagarino will answer with three different statuses:\r\n * **VALID**\r\n * **EXPIRED**\r\n * **NOT_VALID**\r\n\r\nThe answer will carry some more info when the ticket is still valid:\r\n\r\n    http://localhost:8124/tickets/0b4e20ce63f7de9a4a77910e7f909e5dba4538f3/status\r\n    200 OK {\"status\":\"VALID\",\"expires_in\":99,\"policy\":\"requests_based\"}\r\n\r\nIn the previous example the expiration policy and the TTL (Time-To-Live) of the ticket are returned, as well as its status.\r\nThe parameter *\"expires_in\"* has to be read based on the policy of the ticket:\r\n * When the policy is **time_based** then *\"expires_in\"* is the number of seconds before the ticket expires\r\n * When the policy is **requests_based** the value of *\"expires_in\"* is the number of requests before the ticket expires\r\n\r\n\r\n### Expired tickets\r\nExpired tickets are kept in memory by bagarino for 10 days. After that time a call to their status will return \"NOT_VALID\" as it would for a ticket that didn't exist in the first place.\r\n\r\n\r\n### Forceable manual expiration\r\nEven tickets with a policy other than *\"manual_expiration\"* can be forcibly ended by calling the *expire* verb, provided that they had been created with an ad-hoc option, *\"can\\_force\\_expiration\"*:\r\n\r\n\thttp://localhost:8124/tickets/new?policy=requests_based&can_force_expiration=true\r\n    200 OK {\"result\": \"OK\", \"ticket\": \"d81d9b01e323510ba919c0f54fbfba5b7903e326\", \"expires_in\": 100, \"policy\": \"requests_based\"}\r\n\r\nThe result will look identical to any other *requests_based*-policied ticket but the *can\\_force\\_expiration* option enables the call to the *expire* verb to successfully end this ticket life:\r\n\r\n\thttp://localhost:8124/tickets/d81d9b01e323510ba919c0f54fbfba5b7903e326/expire\r\n    200 OK {\"status\": \"EXPIRED\"}\r\n\r\nCreating the ticket without this option and subsequently calling *expire* would have produced the following error:\r\n\r\n\t400 Bad Request {\"status\": \"ERROR\", \"cause\": \"different_policy\"}\r\n\r\n\r\n### Mass-creation of tickets\r\nIt's possible to create more tickets at once by adding the paramenter \"count\" to the query-string of the verb _new_, followed by the number of tickets to be created.\r\nThe maximum number of tickets that can be created this way is capped to prevent overloading the system.\r\nHere's a typical request for mass-creation of tickets:\r\n\r\n    http://localhost:8124/tickets/new?count=4\r\n    200 OK {\"result\":\"OK\",\"tickets\":[\"9c7800ec9cf053e60674042533710c556fe22949\",\"3cd5da62c2ba6d2b6b8973016264282f61f4afdd\",\"7207c7effb2bd8fd97b885a4f72492a97e79babf\",\"75a6cf2ba0454dfe74a4d6ce8baa80881fb76005\"],\"expire_in\":60,\"policy\":\"time_based\"}\r\n\r\n\r\n### Tickets contexts\r\nSometimes it may be useful to bound one or more tickets to a \"context\" so they only acquire a meaning under certain conditions.\r\nIn bagarino this is done by attaching a textual context to the ticket during the \"new\" operation:\r\n\r\n    http://localhost:8124/tickets/new?policy=requests_based&context=mysweetlittlecontext\r\n    200 OK {\"result\":\"OK\",\"ticket\":\"7486f1dcf4fc4d3c4ef257230060aea531d42758\",\"expires_in\":100,\"policy\":\"requests_based\"}\r\n\r\nOnce it's scoped this way requests for that ticket status that don't specify the context won't be able to retrieve it, resulting in a \"not_found\" error, the same given when asking for a non-existent ticket:\r\n\r\n    http://localhost:8124/tickets/7486f1dcf4fc4d3c4ef257230060aea531d42758/status\r\n    404 Not Found {\"status\":\"ERROR\",\"cause\":\"not_found\"}\r\n\r\nThe way to ask for a context-bound token is as follows:\r\n\r\n    http://localhost:8124/tickets/7486f1dcf4fc4d3c4ef257230060aea531d42758/status?context=mysweetlittlecontext\r\n    200 OK {\"status\":\"VALID\",\"expires_in\":99,\"policy\":\"requests_based\"}\r\n\r\n\r\n\r\nLICENSE - Apache License v2\r\n---------------------------\r\nCopyright (c) 2014 Nicola Orritos\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use these files except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n   http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n\r\n","google":"UA-2008228-4","note":"Don't delete this file! It's used internally to help with page regeneration."}